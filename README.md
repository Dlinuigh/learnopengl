# Learn OpenGL

opengl 4.6版本的learnopengl.org代码,估计learnopengl.org上的代码基本上也能用,只是我喜欢最新版,core版本的opengl.
所有的代码经过了可用测试,尽量进行了模块化
glad是仅头文件版本,不需要额外编译,然后放到了`/usr/local/include`目录下.

## Problems

`shader program`不一定专属于某一类物体?
错误,一定要设计成专属于某一个物体,否则会陷入`program`的定义风波,你在想能不能设计一个通用program,就像能不能设计一些通用的glsl代码一样,但是实际上一对glsl代码就应该达到一个渲染效果,而一对代码意味着一个程序.
`uniform attribute`程序里面的参数?到目前为止,我们使用了这些:`model`一个对物体的状态的修改矩阵,`view`相机的信息,`projection`控制相机离物体的距离,以及产生的投影效果,比如近大远小.`light_color`这个色彩是一个自然光,但是颜色没有指定,不过效果就是能够从四面八方投射到物体上并反射出物体本身的颜色,如果自然光的颜色与物体本身的颜色不符那么自然就不能反射显示出黑色.这些参数里面,`light_color`到目前为止是一个未健全设计,?或者健全的自然光.这些信息里面需要这样进行划分:`model`归物体,`view`与`projection`归相机,`light_color`归自然光源.
运行阶段?程序本身可能存在一个物体列表,而后物体里面有program,program需要在一个地方使用一次,然后在一个地方link一次,在一个地方载入所有的glsl代码,然后draw是每一次循环都需要的,draw属于一个物体.在循环外面有use和link,load.有一些参数需要在循环里面有一些在外面.这些函数都交给物体,他需要接受参数时就接受参数,而program确实存在set进行设置参数,当然了program要作为物体的属性.光源也是一个物体.但是是一个特殊的物体,在color.cpp我们暂时看不到区别.物体需要一个set model的方法,给外部控制model并加载到program中.自己还需要记录model.还有一些外部的量可以保存到物体,这些变量是供给program的.
固定的名称?是的,为了后续的方便,必须要确定,在glsl代码中使用统一的名称,我是说uniform变量,比如model就是model,类似的皆如此,我甚至需要一份表格专门指导命名

## Review

`Getting started`、`Lighting`、`Model Loading`复习一下，并且把之前代码里的文件目录结构进行整理。先复习。

首先opengl本身很复杂，插件系统就已经让开发者头疼，我到现在都没有了解到插件相关的热知识，反正就是在glad网站上直接添加全部插件。虽然我看到一些英伟达插件，我的电脑是au加au，反正也不是很大，而且我用的头文件版本所以也不用编译生成源文件，添加方便得很。感谢glad
使用上记得1. 要在glfw的会话开始后使用，makecontext之后。2. 头文件版本要添加
``` cpp
#define GLAD_GL_IMPLEMENTATION
```
在glad前面的源文件里面？我放在头文件里面也没事。

glsl代码，语法类似c，比较简单易懂，有很多版本相关的内嵌函数，uniform加入了编译前确定的参数，而变异后运行中的情况就通过vbo之类的维护传入。所以基本上不能在一个glsl代码中实现“可变数组”。一些变量需要glsl代码先确定名称，然后在程序中进行告知。目前的使用是这样的。

obj模型里面是边、法线、face之类的数据，而mtl保存的是材质相关信息，blender直接在导入模型的时候选中两个，单选一个可能没办法识别。mtl里面的材质可以命名，这样可以在assimp里面用aiMaterial的getname获取。这样可以区分不同的材质。这一点教程里面没有，他用的是一个默认生成名字。这个材质他的几个信息会存储在几张图片里面，在mtl里面会有信息。

opengl的各种资源的函数调用对于顺序确实不够清晰，很多时候可以在这里也可以之后，比如program.use、texture.activate、program.set。对于link是比较清晰的，在程序加载了代码就可以进行link，变成一个整体。而use是一个program之间的间隔。

光线，这个是整个实验比较麻烦的地方，重点是这个东西从设计上就是不那么轻松的，一个物体上面的多种光线需要进行叠加后产生效果，而glsl不能支持动态改变的结构数量，意味着你需要在glsl代码中设定最大光线数量，然后如果数量不满足就少来点计算就行了。而光线本身是一个对于物体才具有作用的物体，光线相互之间默认是无影响的。

相机，在这里定义了一个功能完善的相机，非常舒适，这个物体也没有那么复杂，你只需要注意在主程序中定义所有glfw相关的自动触发函数的handler就行了，剩余的交给各自的类。相机的几个数据设计上也不会有太多改动，整体而言最舒服，从设计好的时候开始就没有什么变化。

mesh和model这两个是设计上变动较多的，mesh是图形的基本信息的最小单元，而model是一个能够传达信息的整体，你需要至少一个mesh才能称之为model。blender建模中，你可以用挤出完成创建复杂图形的目的，而在blender这似乎是一个整体的mesh，而一整个物体（不包括灯光、相机）的组成了model。在这个过程中，我把材质抽离了，因为本来就应该是一个属于材质库的东西。

材质，这个是一些经验得出来的数据的集合，非常感谢前辈的付出。你可以用一些图片快速创建一个纹理，而材质还包含了一些光线造成的影响，由于我们不能用手去摸，所以粗错阿这种模棱两可的数据一般仍然是用光线效果去反映的。在这里我的做法不太好，我没有获得材质的名字？获得了但是没什么意义就抛弃了。然后里面的图片的材质我是照着教程改的，但是我肯定是不喜欢的。我们没有理解为什么他用的是texture_diffuse1进行最终颜色的表现。这一整个模型到glsl代码的过程我比较反感，因为里面的更多细节被忽视了。

数据运算，我承认，我基本上没有认真看数据的计算过程，我的代码里面的这部分就是别人的，所以我会对一些材质之类的数据感到迷惑，当然这可能是因为这个计算过程基本是依赖经验。数据的计算完完全全不用自己推倒就能得到答案。然后由于数学推导需要的3d的图形计算还没有怎么熟悉，比如一个欧拉角就可能引发大的问题。

总结：在这个过程中出现的问题基本得到了妥善的解决，这些问题形形色色，基本难以通过debug判断，因为opengl的代码调试确实方法匮乏，变量被封装得完好。不过记录下来就能避免下一次。最后代码的结构需要进行一次调整。